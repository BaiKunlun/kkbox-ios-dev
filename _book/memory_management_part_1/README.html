<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>Memory Management Part 1 | KKBOX iOS 開發教材</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.3">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="../delegate/README.html" />
    
    
    <link rel="prev" href="../category/README.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book"  data-level="3" data-basepath=".." data-revision="1438326341831">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="selector/README.html">
            
                
                    <a href="../selector/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         Selector
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="category/README.html">
            
                
                    <a href="../category/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Category
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="3" data-path="memory_management_part_1/README.html">
            
                
                    <a href="../memory_management_part_1/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         Memory Management Part 1
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="delegate/README.html">
            
                
                    <a href="../delegate/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         Delegate
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" >KKBOX iOS 開發教材</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_86">
                    
                        <h1 id="">記憶體管理</h1>
<p>記憶體管理是一件極其簡單又極其麻煩的事情。</p>
<h2 id="">記憶體管理在做什麼？</h2>
<p>說它簡單，因為所謂的記憶體管理不過就是兩件事情：一塊記憶體我們是要用，還是不要用；該用的時候就用，不用的時候就釋放。麻煩的地方就在於我們很容易疏忽，而造成用與不用不成對。這就很像開車，開車也不過就是前進與煞車，但是天天路上都會發生車禍。</p>
<p>不成對，就會造成兩種結果：如果用完之後不釋放記憶體，就會造成軟體佔用了一堆沒有用到的記憶體，記憶體用量愈來愈大，造成記憶體用盡，在
iOS 上系統會強制終止我們的應用程式，這種狀況叫做記憶體漏水（Memory
Leak）。</p>
<p>反之，如果一塊記憶體已經被釋放掉了，我們卻還以為這塊記憶體還存在我們可以呼叫的物件，所以當我們嘗試呼叫的時候，才發現這塊記憶體該存在的物件已經不在了，這種狀況叫做
over-release 或是 invalid memory reference，會造成應用程式 crash，crash
log 上面會告訴你錯誤類型是 <code>EXC_BAD_ACCESS</code> 。</p>
<p>處理 over-release 可能是初學者開始學習 Mac OS X 與 iOS
平台的第一個障礙（我覺得通常第二個障礙是搞不懂 delegate
是什麼）：一開始寫程式，程式卻一直莫名其妙的
crash，於是前往網路論壇求救，但是通常也不會有多少人幫忙，因為網路上的其他同行通常都樂於回答問題，但懶得幫別人修
bug。</p>
<p>過去三十年學界與業界也一直努力解決記憶體管理的問題，畢竟在寫軟體的時候，不把力氣放在處理程式邏輯問題，而是這種瑣碎的困擾，對於工程師的生產力是一大傷害，主要提出的解決方案是記憶體自動回收（Garbage
Collection，GC），在軟體執行時，如果發現已經沒有任何一個變數指向某塊記憶體，就代表這塊記憶體再也用不到，於是開始回收這塊記憶體。90
年代之後誕生的程式語言，幾乎都有 GC 機制。</p>
<p>蘋果曾經推出 Mac OS X 10.5 時，在 Mac OS X 上實作了
GC，同時也帶動一些使用 GC 的動態語言開始與 Cocoa Framework 橋接，誕生了
PyObjC、MacRuby、RubyCocoa、JSTalk 專案，我們因此也可以使用
Python、Ruby、JavaScript 等語言，直接撰寫 Mac OS X
應用程式。但是，蘋果所實作的 GC，問題不小。</p>
<p>但我過去參與一項專案，在 Mac OS X 10.6 上面以 GC
開發一個軟體，結果可說是淒慘無比：整個 Cocoa Framework 是架構在很多 C
library 上的，而底層許多 library 其實並不支援 GC，我們發現只要在 main
thread 之外用到像是 <code>NSDateFormatter</code> 、 <code>NSNumberFormatter</code> 這些
class（這些 class 架構在 libICU 上，是 IBM 的一項 Open Source
專案，用來處理多國語系的格式問題，同時也是一套 Regular Expression
引擎），GC 就完全沒有作用，記憶體狂漏不止。蘋果在推出 iOS
之後，也始終不在 iOS 上實作 GC。</p>
<p>隨著蘋果在 Compiler 的投資逐漸展露成果，逐步將 Compiler 從 GCC 換成
LLVM，最後決定改變技術方向，從另外一種方向來解決將記憶體管理自動化的問題，就是在
iOS 5 上推出的 ARC（Automatic Reference Counting），不在 runtime
回收記憶體，而是在編譯程式的時候，自動幫你加上與記憶體釋放有關的程式碼。</p>
<p>雖然 ARC
推出的目的就是希望你以後再也不要為記憶體管理問題煩惱，但問題是，實際上，你還是得知道記憶體管理是怎麼運作的。—記得有人打比方說，GC
是自排車，而 Objective-C
的記憶體管理就像開手排車，要自己知道怎麼進檔對檔，我覺得，加上 ARC
呢，其實還是手排車，只是你訓練了一隻猴子幫你在副駕駛座幫你打檔，而你接下來，還得要學會怎麼調教這一隻猴子。</p>
<h2 id="reference-countretainrelease">Reference Count/Retain/Release</h2>
<p>Objective-C 語言裡頭每個物件，都是指向某塊記憶體的指標，在 C
語言當中，你會使用像是 <code>malloc</code> 、 <code>calloc</code> 這些 function
配置記憶體，用完之後，就呼叫 <code>free</code>
釋放記憶體。但是我們如何知道一塊記憶體被多少地方用到，之後這些地方又不再用到呢？所以在
Objective-C
語言發展之初，就建立了一套計算有多少地方用到某個物件的簡單機制，叫做
<em>reference count</em>
，意義非常簡單：只要一個物件被某個地方用到一次，這個地方就對這個物件加一，反之就減一，如果數字減到變成了零，就該釋放這塊記憶體。</p>
<p>一個物件如果使用 <code>alloc</code> 、 <code>init</code> …產生，初始的 reference count 為
1。接著，我們可以使用 <code>retain</code> 增加 reference count。</p>
<pre><code class="lang-objc">[anObject retain]; <span class="hljs-comment">// 加 1</span>
</code></pre>
<p>反之就用 <code>release</code> ：</p>
<pre><code class="lang-objc">[anObject release]; <span class="hljs-comment">// 減 1</span>
</code></pre>
<p>我們可以使用 <code>retainCount</code> 檢查某個物件被 retain 了多少次。</p>
<pre><code class="lang-objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Retain count: %d"</span>, [anObject retainCount]);
</code></pre>
<p>有了基本概念之後，我們就可以看出以下程式有什麼問題</p>
<pre><code class="lang-objc"><span class="hljs-keyword">id</span> a = [[<span class="hljs-built_in">NSObject</span> alloc] init];
[a release];
[a release];
</code></pre>
<p>因為在第二行，a
所指向的記憶體已經被釋放了，所以第三行想要再釋放一次，就會造成錯誤。同樣的：</p>
<pre><code class="lang-objc"><span class="hljs-keyword">id</span> a = [[<span class="hljs-built_in">NSObject</span> alloc] init];
<span class="hljs-keyword">id</span> b = [[<span class="hljs-built_in">NSObject</span> alloc] init];
b = a;
[a release];
[b release];
</code></pre>
<p>在第三行中，由於 b 指向了 a 原本所指向的記憶體，但是 b
原本所指向的記憶體卻沒有釋放，同時再也沒有任何變數指向 b
原本指向的記憶體，因此這塊記憶體就發生了記憶體漏水。接著，在第四行呼叫
<code>[a release]</code> 時，這塊記憶體就已經被放掉了，但是由於 a 與 b
都已經指向了同一塊記憶體，所以第五行的 <code>[b release]</code>
也是操作同一塊記憶體，於是會發生 <code>EXC_BAD_ACCESS</code> 錯誤。</p>
<h2 id="auto-release">Auto-Release</h2>
<p>如果我們今天有一個 method，會回傳一個 Objective-C 物件，假使寫成這樣：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)one
{
    <span class="hljs-keyword">return</span> [[<span class="hljs-built_in">NSNumber</span> alloc] initWithInt:<span class="hljs-number">1</span>];
}
</code></pre>
<p>那麼，每次用到了由 one 這個 method
產生出來的物件，用完之後，都需要記住要 release
這個物件，很容易造成疏忽。慣例上，我們會讓這個 method 回傳 auto-release
的物件。像是寫成這樣：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)one
{
    <span class="hljs-keyword">return</span> [[[<span class="hljs-built_in">NSNumber</span> alloc] initWithInt:<span class="hljs-number">1</span>] autorelease];
}
</code></pre>
<p>所謂的 auto-release 其實也沒有多麼自動，而是說，在這一輪 runloop
中我們先不釋放這個物件，讓這個物件可以在這一輪 runloop
中都可以使用，但是先打上一個標籤，到了下一輪 runloop 開始時，讓 runtime
判斷有哪些前一輪 runloop 中被標成是 auto-release 的物件，這個時候才減少
retain count 決定是否要釋放物件。</p>
<p>我們在這邊遇到了一個陌生的名詞： Runloop ，同一個概念在 Windows
平台或許會稱為 Message Loop 。Runloop
就是事件的循環，我們先來想一個簡單的問題：當我們在開發 Mac OS X 或是 iOS
軟體的時候，程式進入點是在 main.m 裡頭，執行 <code>main()</code> ，為什麼 <code>main()</code>
不會跑完馬上結束，而是會讓應用程式可以繼續執行？</p>
<p>原因是，在 <code>main()</code>
中，我們會建立一個不斷執行的迴圈，在每一輪迴圈中的開始，會從硬體收取硬體事件，像是鍵盤、滑鼠、觸控事件等，在發現硬體事件之後，應用程式首先將事件送給對應到這個事件所在位置的視窗（
<code>NSWindow</code> 物件或是 <code>UIWindow</code>
物件），接著視窗物件會將事件送給負責處理的 UI
元件，這個目前負責應該處理事件的最上層元件，我們則稱之為 First Responder
。這樣的迴圈，就叫做 Runloop 。</p>
<p>在建立 Foundation 物件的時候，除了可以呼叫 <code>alloc</code> 、 <code>init</code> 以及 <code>new</code>
之外（ <code>new</code> 這個 method 其實就相當於呼叫了 <code>alloc</code> 與 <code>init</code>
；比方說，我們呼叫 <code>[NSObject new]</code> ，就等同於呼叫了
<code>[[NSObject alloc] init]</code> 。），還可以呼叫另外一組與物件名稱相同的
method。</p>
<p>以 <code>NSString</code> 為例，有一個叫做 <code>initWithString</code> 的 instance
method，就有一個對應的 class method 叫做 <code>stringWithFormat</code> ，使用這一組
method，就會產生 auto-release 的物件。也就是說，呼叫了
<code>[NSString stringWithFormat:...]</code> ，相當於呼叫了
<code>[[[NSString alloc] initWithFormat:...] autorelease]</code> 。使用這一組
method，可以讓程式碼較為精簡。</p>
<h2 id="">基本原則</h2>
<p>先整理一下我們已經學到的事情：</p>
<ul>
<li>如果是 <code>init</code> 、 <code>new</code> 、 <code>copy</code> 這些 method
產生出來的物件，用完就該呼叫 <code>release</code> 。</li>
<li>如果是其他一般 method 產生出來的物件，就會回傳 auto-release
物件、或是 <code>Singleton</code> 物件（稍晚會解釋什麼是
Singleton），就不需要另外呼叫 <code>release</code> 。</li>
</ul>
<p>而呼叫 retain 與 release 的時機包括：</p>
<ul>
<li>如果是在一般程式碼中用了某個物件，用完就要 release 或是
auto-release。</li>
<li>如果是要將某個 Objective-C
物件，變成是另外一個物件的成員變數，就要將物件 retain 起來。但是
delegate 物件不該 retain，我們稍晚會討論什麼是 delegate。</li>
<li>在一個物件被釋放的時候，要同時釋放自己的成員變數，也就是要在實作
dealloc 的時候，釋放自己的成員變數。</li>
</ul>
<p>要將某個物件設為另外一個物件的成員變數，需要寫一組
getter/setter。我們接下來要討論怎麼寫 getter/setter。</p>
<h2 id="gettersetter--property-">Getter/Setter 與 Property 語法</h2>
<p>Getter 就是用來取得某個物件的某個成員變數的 method，setter
則是用來設定成員變數。如果某個成員變數是 C 的型別，像是
int，我們可以這麼寫。假使我們有個 Class 叫做 MyClass，成員變數是
number：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span>:<span class="hljs-title">NSObject</span></span>
{
    <span class="hljs-keyword">int</span> number;
}
- (<span class="hljs-keyword">int</span>)number;
- (<span class="hljs-keyword">void</span>)setNumber:(<span class="hljs-keyword">int</span>)inNumber;
<span class="hljs-keyword">@end</span>
</code></pre>
<p>我們建立了 setter 叫做 <code>setNumber:</code> ，而 getter 叫做 <code>number</code>
。請注意，在其他語言的慣例中，getter 可能會取名叫做 <code>getNumber</code>，但是
Objective-C 語言的慣例則是只取 <code>number</code> 這樣的名稱。實作則是：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">int</span>)number
{
    <span class="hljs-keyword">return</span> number;
}
- (<span class="hljs-keyword">void</span>)setNumber:(<span class="hljs-keyword">int</span>)inNumber
{
    number = inNumber;
}
</code></pre>
<p>如果是 Objective-C
物件，我們則要將原本成員變數已經指向的記憶體位置釋放，然後將傳入的物件
retain 起來。可能像這樣：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">id</span>)myVar
{
    <span class="hljs-keyword">return</span> myVar;
}
- (<span class="hljs-keyword">void</span>)setMyVar:(<span class="hljs-keyword">id</span>)inMyVar
{
    [myVar release];
    myVar = [inMyVar retain];
}
</code></pre>
<p>假如今天我們在開發的應用程式裡頭用到了很多個 thread，而在不同的 thread
中，同時會用到 myVar，這麼寫其實並不安全：在某個 thread 中呼叫了
<code>[myVar release]</code> 之後，到 mvVar 指定到 inMyVar 的位置之間，假使另外一個
thread 剛好用到了 myVar，這時候 myVar
剛好指到了一塊已經被釋放的記憶體，於是就造成了 <code>EXC_BAD_ACCESS</code> 錯誤。</p>
<p>要避免這種狀況，一種方法是加上一些 lock，讓程式在呼叫 <code>setMyVar:</code>
的時候，不讓其他 thread 可以使用
myVar；另外一種簡單的方法是，只要一直不要讓 myVar
指定到可能被釋放的記憶體位置。我們可以這麼改寫：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)setMyVar:(<span class="hljs-keyword">id</span>)inMyVar
{
    <span class="hljs-keyword">id</span> tmp = myVar;
    myVar = [inMyVar retain];
    [tmp release];
}
</code></pre>
<p>我們先將 myVar 原本指向的記憶體位置，暫存在一個變數中，接著直接將 myVar
指到傳入的記憶體位置，接著再釋放 tmp
變數中所記住的、原本的記憶體位置。由於每次都要這麼寫，寫久了會覺得麻煩，通常會寫成一個
macro，或是直接使用 Objective-C 2.0 裡頭的 property 語法。</p>
<p>相信在開始學習開發 Mac OS X 與 iOS
程式的時候，大部分書籍一開始就示範如何使用 property
語法。也就是，像我們上面的例子，用 property 語法可以寫成：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span>:<span class="hljs-title">NSObject</span></span>
{
    <span class="hljs-keyword">id</span> myVar;
    <span class="hljs-keyword">int</span> number;
}
<span class="hljs-keyword">@property</span> (retain, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> myVar;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">int</span> number;
<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span>
- (<span class="hljs-keyword">void</span>)dealloc
{
    [myVar release];
    [<span class="hljs-keyword">super</span> dealloc];
}
<span class="hljs-keyword">@synthesize</span> myVar;
<span class="hljs-keyword">@synthesize</span> number;
<span class="hljs-keyword">@end</span>
</code></pre>
<p>我們在這邊使用了 <code>@synthesize</code>
語法，在編譯我們的程式的時候，其實就會被編譯成我們在上面所寫的
getter/setter，而我們想要設定 myVar 的內容時，除了可以呼叫 <code>setMyVar:</code>
之外，也可以呼叫 dot 語法，像是 <code>myObject.myVar = someObject</code> 。</p>
<p>我們需要注意，在釋放記憶體的時候， <code>myVar = nil</code> 與 <code>self.myVar = nil</code>
這兩段程式是不一樣的，前者只是單純的將 myVar 的指標指向
nil，但是並沒有釋放原本所指向的記憶體位置，所以會造成記憶體漏水，但後者卻等同於呼叫
<code>[self setMyVar:nil]</code> ，會先釋放 myVar 原本指向的位置，然後將 myVar 設成
nil。</p>
<p>在這邊先補充一下，在 Xcode 4.4 之後，如果用了 property
語法，我們甚至不用宣告對應的成員變數，compiler
在編譯程式的時候，會自動補上 myVar 與 number 需要對應的成員變數。</p>
<p>偶而我們可以在網路上面聽到一些聲音，認為初學者應該避免使用
property，主要原因除了上述 <code>myVar = nil</code> 與 <code>self.myVar = nil</code>
這兩者容易搞混之外，property 的 dot 語法，又與 C 的 structure
語法相同，在還不熟悉的狀況下，很容易讓初學搞錯哪些是
property，哪些又是屬於一個 structure。</p>
<p>例如，我們想要知道一個 view 的 x 座標是在哪裡，會寫出像
<code>self.view.frame.origin.x</code> 這種程式，就需要知道，<code>view</code> 是 <code>self</code> 的
property， <code>frame</code> 也是 <code>view</code> 的 property，但是 <code>x</code> 卻是 <code>origin</code> 這個
<code>CGPoint</code> 裡頭的變數，而 <code>origin</code> 也是 <code>frame</code> 這個 <code>CGRect</code>
裡頭的變數，但是初學的時候很容易搞混。</p>
<p>我們想要取得 x，可以寫成 <code>self.view.frame.origin.x</code> ，但想要設定 x
的位置，如果這麼寫：</p>
<pre><code class="lang-objc"><span class="hljs-keyword">self</span><span class="hljs-variable">.view</span><span class="hljs-variable">.frame</span><span class="hljs-variable">.orgin</span><span class="hljs-variable">.x</span> = <span class="hljs-number">0.0</span>;
</code></pre>
<p>程式會發生編譯錯誤。 <code>self.view.frame.origin.x</code> 其實會被編譯成
<code>[[self view] frame].origin.x</code> ，這沒問題，但是如果要改變 view 的
frame，我們還是要透過 <code>setFrame:</code> ，所以即使只是要改變 x
座標的位置，我們還是得要這麼寫：</p>
<pre><code class="lang-objc"><span class="hljs-built_in">CGRect</span> originalFrame = <span class="hljs-keyword">self</span><span class="hljs-variable">.view</span><span class="hljs-variable">.frame</span>;
originalFrame<span class="hljs-variable">.origin</span><span class="hljs-variable">.x</span> = <span class="hljs-number">0.0</span>;
<span class="hljs-keyword">self</span><span class="hljs-variable">.view</span><span class="hljs-variable">.frame</span> = originalFrame;
</code></pre>
<p>其實這兩點要搞清楚並不困難，如果因為這些緣故而不使用 property
語法，實在有些因噎廢食，因為使用 property
語法，可以大幅精簡程式碼。而由於前述 Xcode 4.4 可以在宣告 property
之後，由 compiler 自動補上對應的成員變數的特性，也不致於會搞錯
<code>myVar = nil</code> 與 <code>self.myVar = nil</code> 的差別—因為我們並沒有宣告 <code>myVar</code>
，如果寫成前者，編譯時會產生錯誤。</p>
<h2 id="uiviewcontroller-"><code>UIViewController</code> 的記憶體管理議題</h2>
<p>來談一些在 iOS 上與記憶體管理相關的重點。</p>
<h3 id="lazy-loading">Lazy Loading</h3>
<p>由於 iOS 裝置的資源相較於 Desktop
平台，並不充裕，為了在資源有限的裝置上有效利用記憶體，以及讓啟動程式的速度變得更快，相較於
Mac OS X，iOS 大量使用 <strong>Lazy Loading</strong> ：
<em>我們要去使用某個物件的時候，我們才去建立那個物件</em> 。 <sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>我們在開發 iOS 應用程式的時候，最常使用的 <code>UIViewController</code> ，就是使用
Lazy Loading 好例子。 <code>UIViewController</code>
負責管理在應用程式中每個會用到的畫面，最主要的屬性就是 <code>view</code>
，當我們在透過 <code>alloc</code> 、 <code>init</code> 或 <code>initWithNibName:bundle:</code> 建立一個
View Controller 的時候，並不會馬上建立 view，而是當我們呼叫 <code>view</code>
這個屬性的時候才會建立。我們以下面的程式為例：</p>
<pre><code class="lang-objc"><span class="hljs-comment">// 建立 MyViewController 的 instance，這時候還沒有建立 view</span>
MyViewController *controller = [[MyViewController alloc]
    initWithNibName:NSStringFromClass([MyViewController class]) bundle:<span class="hljs-literal">nil</span>];
<span class="hljs-comment">// 在被加入到 navigation stack 的時候，會去呼叫 [controller view]</span>
<span class="hljs-comment">// 這時候 view 才被建立起來</span>
[navigationController pushViewController:controller animated:<span class="hljs-literal">YES</span>];
[controller release];
</code></pre>
<p>用 Lazy Loading 的方式實作一個 getter
的方式大致如下。在我們自己的程式中，想要有效使用記憶體，我們也可以嘗試這麼寫。</p>
<pre><code class="lang-objc">- (<span class="hljs-built_in">UIView</span> *)view
{
    <span class="hljs-keyword">if</span> (!_view) {
        _view = [[<span class="hljs-built_in">UIView</span> alloc]
            initWithFrame:[UIScreen mainScreen]<span class="hljs-variable">.bounds</span>];
    }
    <span class="hljs-keyword">return</span> view;
}
</code></pre>
<p>不過，<code>UIViewController</code> 在還沒有 view，而要去建立 view
的時候，會呼叫的其實是 <code>loadView</code> 這個 method，在 view
成功載入之後，則會呼叫 <code>viewDidLoad</code> 。我們雖然不知道蘋果到底是怎麼實作
<code>UIViewController</code> ，但不外乎類似這樣：</p>
<pre><code class="lang-objc">- (<span class="hljs-built_in">UIView</span> *)view
{
    <span class="hljs-keyword">if</span> (!_view) {
        [<span class="hljs-keyword">self</span> loadView];
        <span class="hljs-keyword">if</span> (_view) {
            [<span class="hljs-keyword">self</span> viewDidLoad];
        }
    }
    <span class="hljs-keyword">return</span> view;
}
</code></pre>
<p>所以，如果你有天不小心寫出像下面的程式碼，就會進入無窮迴圈：因為呼叫
<code>[self view]</code> 的時候發現沒有 view，就會呼叫 <code>loadView</code> ，但 <code>loadView</code>
又去呼叫 <code>[self view]</code> 。</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)loadView
{
    [<span class="hljs-keyword">self</span> view];
}
</code></pre>
<h3 id="memory-warnings">記憶體不足警告（Memory Warnings）</h3>
<p>在 Desktop
作業系統中，如果實體記憶體不足，應用程式使用的記憶體量，超過實體記憶體的數量，這時候作業系統會自動將記憶體中的部分資料，存入磁碟的虛擬記憶體（Virtaul
Memory）當中，需要使用的時候，再從虛擬記憶體中載回實體記憶體，Mac OS X
就有這樣的機制。</p>
<p>iOS
在發展之初到現在，都沒有虛擬記憶體，而是會在記憶體快要用完的時候，對應用程式發出記憶體不足警告，要求釋放一些可以暫時不需要用到的物件，讓應用程式可以有足夠的記憶體繼續運作。如果無視記憶體警告，繼續放任記憶體用量成長，系統最後便會強制要求終止應用程式。</p>
<p>在記憶體不足的時候，除了會對 <code>UIApplication</code> 的 delegate 呼叫
<code>applicationDidReceiveMemoryWarning:</code> 之外，也會對系統中所有的
<code>UIViewController</code> 呼叫 <code>didReceiveMemoryWarning</code>
。我們雖然知道要實作這些
method，但是一定會這麼一問：我們之所以會將資料載入到記憶體中，就代表我們會用到這些資料，這些東西都是有用的，哪有應該釋放的道理？</p>
<p>我們不妨看看蘋果自己認為什麼是該釋放的物件。從 iOS 2 到 iOS
5，在發生記憶體警告的時候，系統除了發出通知之外，還會多做一件事情，就是是放不在最前景的
view controller 的 view 物件。</p>
<p>所謂不在最前景的 view controller 像這樣：假如我們今天有一個 tab bar
controller，tab bar 裡頭有四個項目，對應到四個 view
controller，但是其實只會顯示一個，那麼，在發生記憶體警告的時候，其他三個
view controller 的 view 就可以先放掉；在 navigation controller 的
navigation stack 裡頭，也只有最上面的 view controller
的畫面需要顯示，我們也可以釋放其他 view controller 的 view。這些 view
controller 的 view 既然被釋放了，但是沒關係，因為 <code>view</code> 屬性是透過 Lazy
Loading 實作的，下次我們要切換到這些畫面的時候，view 又會被重新載入。</p>
<p>因為 <code>UIViewController</code> 在 iOS 2 到 iOS 5
是這麼實作的，所以我們需要注意幾個重要事項：</p>
<h4 id="-iboutlet-">釋放 IBOutlet 的時機</h4>
<p>如果我們將一個 <code>UIViewController</code> 的 view 放在 XIB
檔案中載入，我們會將像是按鈕等 UI 元件，透過 IBOutlet 連接到我們的 view
controller 的成員變數上，而不同於 Mac OS X，iOS 的 IBOutlet 是會被
retain 起來的，所以我們在不用到這些 IBOutlet
的時候，也要釋放記憶體；而釋放記憶體的時機就不只是寫在 dealloc
裡頭，在收到記憶體警告，view 被釋放的時候，IBOutlet
也要一起釋放—要不然，到了下一次呼叫 loadView 的時候，所有的 IBOutlet
又從 XIB 檔案中載入了一次，就造成了記憶體漏水。</p>
<p>在 iOS 2 的時候，由於系統並不會通知 view
什麼時候被釋放，當時的作法是要在我們的 <code>UIViewController</code> subclass 中
override 掉 <code>setView:</code> 這個 method，如果傳入的參數是 nil，就代表 view
被釋放。程式大致如下：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)setView:(<span class="hljs-built_in">UIView</span> *)inView
{
    [<span class="hljs-keyword">super</span> setView:inView];
    <span class="hljs-keyword">if</span> (inView == ni) {
        <span class="hljs-keyword">self</span><span class="hljs-variable">.button</span> = <span class="hljs-literal">nil</span>; <span class="hljs-comment">// 釋放 IBOutlet</span>
        <span class="hljs-keyword">self</span><span class="hljs-variable">.textView</span> = <span class="hljs-literal">nil</span>;
    }
}
</code></pre>
<p>在 iOS 3 之後，蘋果則要求我們將釋放 IBOutlet 的相關程式碼，放在一個
template method 中，叫做 <code>viewDidUnload</code> 。我們會這麼寫：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)viewDidUnload
{
    [<span class="hljs-keyword">super</span> viewDidUnload];
    <span class="hljs-keyword">self</span><span class="hljs-variable">.button</span> = <span class="hljs-literal">nil</span>;
    <span class="hljs-keyword">self</span><span class="hljs-variable">.textView</span> = <span class="hljs-literal">nil</span>;
}
</code></pre>
<p>請注意：我們在 <code>viewDidUnload</code> 中寫了與釋放 IBOutlet
相關的程式碼，但是記得在 dealloc 的時候還是要再做一次。</p>
<p>蘋果推出 iOS 6 時，或許是認為像是 iPhone 5
這樣的裝置在可用資源上遠遠超越過去的硬體，因此不再需要刻意釋放
<code>UIViewController</code> 的 view 了，因此即使我們實作了 <code>viewDidUnload</code>
，也不會被呼叫到。如果你覺得蘋果過去這一套機制仍然可取，或是你已經有一個做了幾年的
iOS 專案，想要在 iOS 6
上繼續維持過去的記憶體管理策略，我們可以透過下面的範例，自己釋放 view
以及呼叫 <code>viewDidUnload</code> 。</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)didReceiveMemoryWarning
{
    [<span class="hljs-keyword">super</span> didReceiveMemoryWarning];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span><span class="hljs-variable">.isViewLoaded</span> &amp;&amp; !<span class="hljs-keyword">self</span><span class="hljs-variable">.view</span><span class="hljs-variable">.window</span>) {
        <span class="hljs-keyword">self</span><span class="hljs-variable">.view</span> = <span class="hljs-literal">nil</span>;
        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> respondsToSelector:<span class="hljs-keyword">@selector</span>(viewDidUnload)]) {
            [<span class="hljs-keyword">self</span> viewDidUnload];
        }
    }
}
</code></pre>
<h4 id="viewdidload--uiviewcontroller--initializer"><code>viewDidLoad</code> 不是 <code>UIViewController</code> 的 Initializer</h4>
<p>雖然我們在開始使用某個 view controller 之前，一定會呼叫到一次
<code>viewDidLoad</code> ，我們也通常會在這個地方，做一些初始化這個 view controller
的事情，但是並不代表 <code>viewDidLoad</code> 這個 method 的定位就是用來初始化
<code>UIViewController</code> 。</p>
<p>由於 view controller 可能會被重複釋放與載入 view， <code>viewDidLoad</code>
也會被重複呼叫，如果我們只在這編寫初始化 view controller
的程式碼的話，那麼，當我們遇到記憶體警告，再回到這個 view controller
之後，我們預期可以看到之前離開這個 view controller
的狀態，但是看到的卻是重設到初始狀態。所以，在 view
裡頭的內容被改變的時候，view controller 或許要隨時，或是在
<code>viewDidUnload</code> 被呼叫到的時候，記住 view 裡頭的狀態，而在 <code>viewDidLoad</code>
的時候還原到 <code>viewDidUnload</code> 之前的狀態。</p>
<h4 id="ios--view-controller-">iOS 如何知道哪個 View Controller 位在最上層？</h4>
<p>那麼，view controller
自己怎麼知道自己位在最上層或不是，在收到記憶體警告的時候，該不該將 view
釋放呢？其實很簡單：view controller 被放到最上層時，會被呼叫到
<code>viewWillAppear:</code> 以及 <code>viewDidAppear:</code> ，離開最上層時，會呼叫
<code>viewWillDisappear:</code> 與 <code>viewDidDisappear:</code> 。</p>
<p>我們通常會在 view controller 的 view
正要被顯示出來之前做一些事情，比方說，如果我們的畫面中有一個 table
view，我們或許希望每次被顯示出來的時候，都更新一下 table view
的內容，於是在我們自己的 view controller subclass 裡，override 了
<code>viewWillAppear:</code> ，呼叫了一次 table view 的 <code>reloadData</code>
。但我們在做這樣的事情的時候，千萬要記住，必須保留 super
的實作，這樣才能夠保證這套釋放與還原 view 的機制運作正常。</p>
<p>假如我們自己要寫一套像是 <code>UINavigationController</code> 或是
<code>UITabBarController</code> 這類的 class，我們也需要記住呼叫 <code>viewWillAppear:</code>
這些 method。簡單範例如下：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)pushViewController:(<span class="hljs-built_in">UIViewController</span> *)inController
                  animated:(<span class="hljs-built_in">BOOL</span>)animated
{
    [inController view];
    [inController viewWillAppear:animated];
    [[viewControllers lastObject] viewWillDisappear:animated];
    [[[<span class="hljs-keyword">self</span><span class="hljs-variable">.contentView</span> subviews] lastObject] removeFromSuperView];
    inController<span class="hljs-variable">.view</span><span class="hljs-variable">.frame</span> = <span class="hljs-keyword">self</span><span class="hljs-variable">.contentView</span><span class="hljs-variable">.bounds</span>;
    [<span class="hljs-keyword">self</span><span class="hljs-variable">.contentView</span> addSubview:inController<span class="hljs-variable">.view</span>];
    [inController viewDidAppear:animated];
    [[viewControllers lastObject] viewDidDisappear:animated];
    [viewControllers addObject:inController];
}
</code></pre>
<blockquote id="fn_1">
<sup>1</sup>. 也可以參見 Wikipedia 上的說明 <a href="http://en.wikipedia.org/wiki/Lazy_loading" target="_blank">http://en.wikipedia.org/wiki/Lazy_loading</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../category/README.html" class="navigation navigation-prev " aria-label="Previous page: Category"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../delegate/README.html" class="navigation navigation-next " aria-label="Next page: Delegate"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
