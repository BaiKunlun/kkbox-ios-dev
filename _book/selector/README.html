<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>Selector | KKBOX iOS 開發教材</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.3">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="../category/README.html" />
    
    
    <link rel="prev" href="../index.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book"  data-level="1" data-basepath=".." data-revision="1438326341831">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="1" data-path="selector/README.html">
            
                
                    <a href="../selector/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         Selector
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="category/README.html">
            
                
                    <a href="../category/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Category
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="memory_management_part_1/README.html">
            
                
                    <a href="../memory_management_part_1/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         Memory Management Part 1
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="delegate/README.html">
            
                
                    <a href="../delegate/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         Delegate
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" >KKBOX iOS 開發教材</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_87">
                    
                        <h1 id="selector">Selector</h1>
<h2 id="">基本定義</h2>
<p>我個人在學習新事物的時候，通常會這麼挑戰自己：我有沒有辦法用一句話描述這件事物是什麼？還有，這件事物可以用在哪裡？我在接下來的章節中，也會以這樣的方式展開。以
Selector 來說，我個人就會做一個簡短的定義：</p>
<blockquote>
<p><em>Selector 就是用字串表示某個物件的某個 method</em></p>
</blockquote>
<p>那，Selector 有什麼用途呢？</p>
<blockquote>
<p><em>因為 method 可以用字串表示，因此，某個 method
就可以變成可以用來傳遞的參數。</em></p>
</blockquote>
<p>至於要更進一步了解
Selector，我們就要從一些更基本的事情開始講起：Objective-C 裡頭的物件以及
Class，到底是什麼？</p>
<h2 id="objective-c-classobejct-">Objective-C Class/Obejct 到底是什麼？</h2>
<p>你應該在其他的文件裡頭聽說過，Objective-C 是 C 語言的 Superset，在 C
語言的基礎上，加上了一層稀薄的物件導向，而 Cocoa Framework 的 Cocoa
這個名字就是這麼來的—Cocoa 就是 C 加上 OO。也因此，在 Objective-C
程式中，可以直接呼叫 C 的 API，而如果你將 .m 改名叫做
.mm，程式裡頭還可以混和 C++ 語法，變成 Objective-C++。</p>
<p>Objective-C 的程式在 compile time 時，Compiler 其實會編譯成 C
然後繼續編譯。所有的Objective-C Class 會變成 C 的 Structure，所有的
method （以及 block）會被編譯成 C
function，接下來，在執行的時候，Objective-C runtime 才會建立某個 C
Structure 與 C function 的關聯，也就是說，一個物件到底有哪些 method
可以呼叫，是在 runtime 才決定的。</p>
<h3 id="objective-c--structure">Objective-C 物件會被編譯成 Structure</h3>
<p>比方說，我們現在寫了一個簡單的 Class，裡頭只有 int a 這個成員變數：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span> </span>{
    <span class="hljs-keyword">int</span> a;
}
<span class="hljs-keyword">@end</span>
</code></pre>
<p>會被編譯成</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    <span class="hljs-keyword">int</span> a;
} MyClass;
</code></pre>
<p>因為 Objective-C 的物件其實就是 C 的 structure，所以當我們建立了一個
Objective-C 物件之後，我們也可以把這個物件當做呼叫 C structure 呼叫
<sup><a href="#fn_1" id="reffn_1">1</a></sup>：</p>
<pre><code class="lang-objc">MyClass *obj = [[MyClass alloc] init];
obj-&gt;a = <span class="hljs-number">10</span>;
</code></pre>
<h3 id="-class--method">對 Class 加入 method</h3>
<p>在執行的時候，runtime 會為每個 Class
準備好一張表格，表格裡頭會以一個字串當 key，每個 key 會對應到 C function
的指標位置。Runtime 裡頭，把實作的 C function 定義成 <code>IMP</code> 這個
type；至於拿來當作 key 的字串，就叫做 selector，type 定義成 <code>SEL</code>
，然後我們可以使用 @selector 關鍵字建立 selector。而其實 <code>SEL</code> 就是 C
字串，我們可以來寫點程式檢查一下：</p>
<pre><code class="lang-objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%s"</span>, (<span class="hljs-keyword">char</span> *)(<span class="hljs-keyword">@selector</span>(doSomething)));
</code></pre>
<p>我們會順利印出「doSomething」這個 C 字串。</p>
<p>每次我們對一個物件呼叫某個 method，runtime 在做的事情，就是把 method
的名稱當做字串，尋找與字串符合的 C function
實作，然後執行。也就是說，下面這三件事情是一樣的：</p>
<p>我們可以直接要求某個物件執行某個 method：</p>
<pre><code class="lang-objc">[myObject doSomthing];
</code></pre>
<p>或是透過 <code>performSelector:</code> 呼叫。 <code>performSelector:</code> 是 <code>NSObject</code> 的
method，而在 Cocoa Framework 中所有的物件都繼承自 <code>NSObject</code>
，所以每個勿建都可以呼叫這個 method。</p>
<pre><code class="lang-objc">[myObject performSelector:<span class="hljs-keyword">@selector</span>(doSomething)];
</code></pre>
<p>我們可以把 <code>performSelector:</code>
想成台灣的電視新聞用語：如果原本的句子是「我正在吃飯」，使用
<code>performSelector:</code>
就很像是「我正在進行一個吃飯的動作」。而其實，最後底層執行的是
<code>objc_msgSend</code> 。</p>
<pre><code class="lang-objc">objc_msgSend(myObject, <span class="hljs-keyword">@selector</span>(doSomething), <span class="hljs-literal">NULL</span>};
</code></pre>
<p>我們常常會說「要求某個 object 執行某個 methood」、「要求某個 object
執行某個 selector
」，其實是一樣的事情，我們另外也常聽到一種說法，叫做「對 receiver 傳遞
message」，這則是沿用來自 Small Talk 的術語—Objective-C 受到了 Small
Talk 語言的深刻影響—但其實也是同一件事。</p>
<p>因為一個 Class 有哪些 method，是在 runtime
一個一個加入的；所以我們就有機會在程式已經在執行的時候，繼續對某個 Class
加入新 method，一個 Class 已經存在了某個 method，也可以在 runtime
用別的實作換掉，一般來說，我們會用 Category 做這件事情，不過 Category
會是下一章的主題，會在下一章繼續討論。</p>
<p>我們在這裡首先要記住一件非常重要的事：在 Objective-C 中，一個 Class
會有哪些
method，並不是固定的，如果我們在程式中對某個物件呼叫了目前還不存在的
method，編譯的時候，compiler
並不會當做編譯錯誤，只會發出警告而已，而跳出警告的條件，也就只有是否有引入的
header 中到底有沒有這個 method
而已，所以我們一不小心，就很有可能呼叫到了沒有實作的
method（或這麼說，我們要求執行的 selector
並沒有對應的實作）。如果我們是使用 <code>performSelector:</code>
呼叫，更是完全不會有警告。直到實際執行的時候，才發生
unrecognized selector sent to instance 錯誤而導致應用程式 crash。</p>
<p>之所以只有警告，而不當做編譯錯誤，就是因為某些 method
有可能之後才會被加入。蘋果認為你會寫出呼叫到沒有實作的
selector，必定是因為你接下來在某個時候、某個地方，就會加入這個 method
的實作。</p>
<p>由於 Objective-C 語言中，物件有哪些 method 可以在 runtime
改變，所以我們也會將 Objective-C 列入像是 Perl、Python、Ruby
等所謂的動態語言（Dynamic
Language）之林。而在寫這樣的動態物件導向語言時，一個物件到底有哪些
method 可以呼叫，往往會比這個物件到底是屬於哪個 Class 更為重要。 <sup><a href="#fn_2" id="reffn_2">2</a></sup></p>
<p>如果我們不想要用 Category，而想要自己動手寫點程式，手動將某些 method
加入到某個 Class 中，我們可以這麼寫。首先宣告一個 C
function，只少要有兩個參數，第一個參數是執行 method 的物件，第二個參數是
seelctor，這這樣：</p>
<pre><code class="lang-objc"><span class="hljs-keyword">void</span> myMethodIMP(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL _cmd) {
    doSomething();
}
</code></pre>
<p>接下來可以呼叫 <code>class_addMethod</code> 加入 selector 與實作的對應。</p>
<pre><code class="lang-objc"><span class="hljs-preprocessor">#import <span class="hljs-title">&lt;objc/runtime.h&gt;</span></span>
<span class="hljs-comment">// 中間省略</span>
class_addMethod([MyClass class], <span class="hljs-keyword">@selector</span>(myMethod), (IMP)myMethodIMP, <span class="hljs-string">"v@:"</span>);
</code></pre>
<p>接下來就可以這麼呼叫了：</p>
<pre><code class="lang-objc">MyClass *myObject = [[MyClass alloc] init];
[myObject myMethod];
</code></pre>
<h2 id="selector-">Selector 有什麼用途？</h2>
<p>我們會在幾個地方應用 selector：</p>
<h3 id="targetaction-pattern">Target/Action pattern</h3>
<p>Selector 的主要用途，就是實作 target/action。相信你應該試過在 Xcode
中建立一個新專案之後，可能在 Interface Builder 中建立了一個 UIButton
或是 NSButton 物件，然後將按鈕連接到 controller 中宣告成 IBAction 的
method 上，這時候，我們的 Controller 就是 Button 的 target，而要求
controller 執行的 method，就叫做 action。</p>
<p>我們在 Interface Builder
裡頭做的事情，也可以透過程式碼做到。而如果我們想要設計一套系統 Framework
裡頭所沒有的客製 UI 元件，第一步就是要了解怎麼實作 target/action。</p>
<p>在 UIKit 中的 Target/Action
稍微複雜一些，因為同一個按鈕可以一次連接好幾個 target 與
action，我們在這邊使用 AppKit 示範—在 Mac 上，一次只會指定單一的 target
與 action。如果想要產生一個按鈕或是其他的 custom control，我們會繼承自
NSView，然後建立兩個成員變數：target 與 action，action 是一個 selector。</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyButton</span> : <span class="hljs-title">NSView</span></span>
{
    <span class="hljs-keyword">id</span> target;
    SEL action;
}
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-keyword">id</span> target;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>) SEL action;
<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyButton</span></span>
- (<span class="hljs-keyword">void</span>)mouseDown:(NSEvent *)e
{
    [<span class="hljs-keyword">super</span> mouseDown:e];
    [target performSelector:action withObject:<span class="hljs-keyword">self</span>];
}
<span class="hljs-keyword">@synthesize</span> target, action;
<span class="hljs-keyword">@end</span>
</code></pre>
<p>我們在這邊將 target 的型別設定為 id，代表的是任意 Objective-C
物件的指標，如同前面提到，Controller 到底是什麼
class，在這邊並不重要，而且我們也不該將 target 的 class
寫死，因為如此一來，就變成只有某些 Controller 才能使用這個按鈕。</p>
<p>我們接著在 <code>mouseDown:</code> 中，要求 target 執行之前傳入的 action，由於
selector 是字串，是可以傳遞的參數，所以也就可以成為按鈕的成員變數。</p>
<p>我們接下來也可以使用程式碼連結 target 與 action，在 Controller
的程式中，只要這麼寫即可：</p>
<pre><code class="lang-objc">[(MyButton *)button setTarget:<span class="hljs-keyword">self</span>];
[(MyButton *)button setAction:<span class="hljs-keyword">@selector</span>(clickAction:)];
</code></pre>
<p>把要做什麼事情當做參數傳遞，每個語言都有不同的作法。 Objective-C
用的是拿字串來尋找對應的實作 function 指標，在 C
語言裡頭就會直接傳遞指標，一些更高階的語言或著是把一段程式碼當做是字串傳遞，要使用的時候再去
evaluate
這段程式碼字串，或是一段程式碼本身就是一個物件，所以可以把程式碼當做物件傳遞，我們稱之為「匿名函式」（
Anonymous Function ），現在 Objective-C 也有匿名函式，叫做
block，不過，對這個 1983
年誕生的語言來說，這是很晚近才有的功能，我們會稍晚討論。</p>
<h3 id="-method-">檢查 method 是否存在</h3>
<p>前面提到，我們有可能會呼叫到並不存在的
method，如果這麼做就會產生錯誤。但我們有時候會遇到的狀況是：我們並不確定某些
method 到底有沒有實作，如果有，就呼叫，如果沒有，就略過或是使用其他的
method。</p>
<p>這種狀況最常遇到的就是顧及向下相容。比方說，在 iOS 4 之後，才開始支援
Retina Display，我們在繪圖的 code
中要決定現在應該繪製怎樣精細程度的圖片，需要知道目前用的是傳統的一倍品質，還是
Retina Display 的兩倍品質，就要去問 <code>UIScreen</code> 的 <code>scale</code>
屬性。但是，當我們開始支援 iOS 4 的時候，可能還要顧及 iOS 3
的使用者，導致我們不能夠貿然直接呼叫 <code>scale</code>
（當然，如果你的應用程式都只支援最新版本的作業系統，那是再幸福不過的事），而是要去檢查這個屬性是否存在，如果沒有，就代表使用者的作業系統是
iOS 4
之前的版本，我們只需要提供一倍品質的圖片就可以了。在未來，只要遇到向下相容，我們就還是得處理這樣的狀況。</p>
<p>另外，雖然蘋果只允許 iOS
上面的應用程式只能夠是單一的執行檔，不能夠在執行時載入其他的
binary，但是在 Mac OS X 上面卻可以載入 loadable
bundle，或是在應用程式中放置 private framework，一個物件的某些 method
可以不在主程式中，而是在 plug-in 中實作。我們也要做這樣的檢查。</p>
<p>檢查某個物件是否實作了某個 method，只要呼叫 <code>respondsToSelector:</code>
就可以了：</p>
<pre><code class="lang-objc"><span class="hljs-built_in">BOOL</span> scale = <span class="hljs-number">1.0</span>;
<span class="hljs-keyword">if</span> ([[UIScreen mainScreen] respondsToSelector:<span class="hljs-keyword">@selector</span>(scale)]) {
    scale = [UIScreen mainScreen]<span class="hljs-variable">.scale</span>;
}
</code></pre>
<p>在其他程式語言中，也需要這樣檢查 method 是否存在嗎？在 Ruby
語言中，有類似的 <code>respond_to?</code> 語法，至於 Python，我們或著可以用 <code>dir</code>
這個 funciton 檢查某個物件的全部 attribute 中是否存在對應到某個 method
的 key，但是更常見的作法就是使用 try…catch 語法，如果遇到某個 method
可能不存在，就包在 try…catch 的 block 中，像是：</p>
<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    myObject.doSomething()
<span class="hljs-keyword">except</span> Exception, e:
    <span class="hljs-keyword">print</span> <span class="hljs-string">"The method does not exist."</span>
</code></pre>
<p>在 Objective-C 中，同樣也有 try…catch 語法，在許多語言中，善用
try…catch，也可以將程式寫得清楚有條理，但是我們並不鼓勵在 Objective-C
語言中使用。原因與 Objective-C 的記憶體管理機制有關，如果大量使用
try…catch，會導致記憶體漏水（Memory Leak）。</p>
<p>Objective-C 本身並不算有記憶體回收機制（Garbage Collection，以下簡稱
GC）的語言，雖然在 Mac OS X 10.5 的時代，蘋果嘗試在 Objective-C 上實作
GC，但是成果實在不甚理想，如果貿然在 Mac OS X 上大量使用
GC，實際運作會有嚴重的記憶體漏水問題；蘋果在推出 iOS
之後，也不敢將這套機制用在行動裝置上，而是在 iOS 5 時放棄在 runtime
管理記憶體，而是推出 ARC（Automatic Reference Counter），在 compile time
時決定什麼時候應該釋放記憶體。</p>
<p>由於傳統的 Objective-C 記憶體管理大量使用一套叫做 auto-release
的機制—雖然說是
auto，其實也沒多自動，頂多算是半自動—將一些應該要釋放的物件延遲釋放，在這一輪
runloop 中先不釋放，而是到了下一輪 runloop
開始時才釋放這些記憶體。如果使用 try…catch 捕捉例外錯誤，就會跳出原本的
runloop，而導致應該釋放的記憶體沒被釋放。</p>
<h3 id="timer">Timer</h3>
<p><code>NSObject</code> 除了 <code>performSelector:</code> 這個 method 之外，同樣以
performSelector 開頭的，還有好幾組 API 可以呼叫，例如
<code>-performSelector:withObject:afterDelay:</code>
，就可以讓我們在一定的秒數之後，才要求某個 method 執行。</p>
<pre><code class="lang-objc">[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(doSomething) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">1.0</span>];
</code></pre>
<p>如果時間還不到已經預定要執行的時間，method
還沒有執行，我們也可以反悔，取消剛才預定要執行的 method，只要呼叫
<code>cancelPreviousPerformRequestsWithTarget:</code> 即可。如以下範例：</p>
<pre><code class="lang-objc">[<span class="hljs-built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="hljs-keyword">self</span>];
</code></pre>
<p><code>performSelector:withObject:afterDelay:</code> 的效果相當於產生 <code>NSTimer</code>
物件，當我們想要延遲呼叫某個
method，或是要某件事情重複執行，都可以透過建立 <code>NSTimer</code>
物件達成，要使用 timer，我們也必須使用 selector 語法。</p>
<p>我們先定義一個 timer 要做的事情：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)doSomething:(NSTimer *)timer
{
    <span class="hljs-comment">// Do something</span>
}
</code></pre>
<p>然後透過 <code>doSomething:</code> 的 selector 建立 timer</p>
<pre><code class="lang-objc">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span>
                          target:someObject
                          selector:<span class="hljs-keyword">@selector</span>(doSomething:)
                          userInfo:<span class="hljs-literal">nil</span>
                          repeats:<span class="hljs-literal">YES</span>];
</code></pre>
<p>除了透過指定 target 與 selector 之外，還可以透過指定 <code>NSInvocation</code>
呼叫建立 <code>NSTimer</code> 物件；<code>NSInvocation</code> 其實就是將 target/action
以及這個 action 中要傳遞給 target 的參數這三者，再包裝成一個物件。呼叫的
method 是 <code>scheduledTimerWithTimeInterval:invocation:repeats:</code>。</p>
<p>透過建立 <code>NSInvocation</code> 物件建立 timer 的方式如下。</p>
<pre><code class="lang-objc">NSMethodSignature *sig = [MyClass instanceMethodSignatureForSelector:
                                  <span class="hljs-keyword">@selector</span>(doSomething:)];
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig];
[invocation setTarget:someObject];
[invocation setSelector:<span class="hljs-keyword">@selector</span>(doSomething:)];
[invocation setArgument:&amp;anArgument atIndex:<span class="hljs-number">2</span>];
NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span>
                          invocation:invocation
                          repeats:<span class="hljs-literal">YES</span>];
</code></pre>
<p>請注意，在呼叫 <code>NSInvocation</code> 的 <code>setArgument:atIndex</code>
的時候，我們要傳遞的參數，要從 2 開始，因為在這邊我們要想成，這是給
<code>objc_msgSend</code> 呼叫用的參數，在 0 的參數是物件的 self，位在 1 的則是
selector。</p>
<h3 id="-nsnotification">接收 <code>NSNotification</code></h3>
<p>我們稍晚才會討論 <code>NSNotification</code> 以及 <code>NSNotificationCenter</code>
，不過在這邊先簡單提到：如果我們要接收 <code>NSNotification</code>
，我們也要在開始訂閱通知的時候，指定要由哪個 selector 處理這個通知。</p>
<h3 id="-thread--method">在某個 Thread 執行 method</h3>
<p>除了已經提到的 <code>-performSelector:withObject:afterDelay:</code> 之外，
<code>NSObject</code> 還有好幾個 method，是讓指定的 selector 丟到某個 Thread
執行，包括：</p>
<ul>
<li><code>-performSelectorOnMainThread:withObject:waitUntilDone:modes:</code></li>
<li><code>-performSelectorOnMainThread:withObject:waitUntilDone:</code></li>
<li><code>-performSelector:onThread:withObject:waitUntilDone:modes:</code></li>
<li><code>-performSelector:onThread:withObject:waitUntilDone:</code></li>
<li><code>-performSelectorInBackground:withObject:</code></li>
</ul>
<p>假如有一件事情—在這邊叫做
doSomething—會執行太久，我們可以將這件事情丟到背景，也就是另外建立一條
Thread 執行：</p>
<pre><code class="lang-objc">[<span class="hljs-keyword">self</span> performSelectorInBackground:<span class="hljs-keyword">@selector</span>(doSomething) withObject:<span class="hljs-literal">nil</span>];
</code></pre>
<p>注意，在背景執行時，這個 method 的內部需要建立自己的 Auto-Release Pool。</p>
<p>執行完畢後，我們可以透過
<code>-performSelectorOnMainThread:withObjectwaitUntilDone:</code> ，通知主 Thread
我們已經把事情做完了。像是，如果我們要轉換一個比較大的檔案，就可以在背景實際轉檔，轉完之後，再告訴主
Thread，在 UI 上跳出提示視窗，提示使用者已經轉檔完畢。</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)doSomthing
{
    <span class="hljs-keyword">@autoreleasepool</span> {
        <span class="hljs-comment">// Do something here.</span>
        [<span class="hljs-keyword">self</span> performSelectorOnMainThread:<span class="hljs-keyword">@selector</span>(doAnotherThing)
              withObject:<span class="hljs-literal">nil</span>
              waitUntilDone:<span class="hljs-literal">NO</span>];
    }
}
</code></pre>
<h3 id="array-">Array 排序</h3>
<p>我們今天想要對 <code>NSArray</code> 做排序，就得要告訴這個 Array
怎樣比較裡頭每個東西的大小，所以我們需要把怎麼比較大小這件事情傳遞到
array 上。 Cocoa Framework 提供三種方式排序
Array，我們可以把怎麼比大小寫成 C Function，然後傳遞 C Function
的指標，現在也可以傳遞 Block，而如果 Array 裡頭的物件有負責比較大小的
method 的話，我們也可以透過 selector 指定要用哪個 method 排序。</p>
<p><code>NSString</code>、<code>NSDate</code>、<code>NSNumber</code> 以及 <code>NSIndexPath</code>，都提供 <code>compare:</code>
這個 method，假如有一個 array 裡頭都是字串的話，我們就可以使用
<code>compare:</code> 排序， <code>NSString</code> 用來比較大小順序的 method
與選項（像是是否忽略大小寫，字串中如果出現數字，是否要以數字的大小排列而不是只照字元順序…等等），其中最常用的，該是
<code>localizedCompare:</code> ，這個 method
會參考目前使用者所在的系統語系決定排序方式，像是簡體中文語系下用拼音排序，繁體中文語系下用筆劃排序…等等。</p>
<p>我們使用 <code>sortedArrayUsingSelector:</code> 產生重新排序的新 Array，如果是
<code>NSMutableArray</code>，則可以呼叫 <code>sortUsingSelector:</code></p>
<pre><code class="lang-objc"><span class="hljs-built_in">NSArray</span> *sortedArray = [anArray sortedArrayUsingSelector:
                                 <span class="hljs-keyword">@selector</span>(localizedCompare:)];
</code></pre>
<p>我們也可以透過傳遞 selector，要求 Array 裡頭每一個物件都執行一次指定的
method。</p>
<pre><code class="lang-objc">[anArray makeObjectsPerformSelector:<span class="hljs-keyword">@selector</span>(doSomething)];
</code></pre>
<h3 id="-ifelse--switchcase">代替 if...else 與 switch…case</h3>
<p>因為 selector 其實就是 C 字串，除了可以當做參數傳遞之外，也可以放在
array 或是 dictionary 裡頭。有的時候，如果你覺得寫一堆 if…else 或是
switch…case 太過冗贅，例如，原本我們可能這麼寫：</p>
<pre><code class="lang-objc"><span class="hljs-keyword">switch</span>(condition) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        [object doSomething];
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
        [object doAnotherThing];
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>如果沒有什麼會超過邊界的問題的話，其實可以考慮搭配 Xcode 4.4
之後所提供的 literal 新寫法 <sup><a href="#fn_3" id="reffn_3">3</a></sup> ，看起來就精簡一些。</p>
<pre><code class="lang-objc">[object performSelector:NSSelectorFromString(@[<span class="hljs-string">@"doSomething"</span>,
    <span class="hljs-string">@"doAnotherThing"</span>][condition])];
</code></pre>
<p>我們可以使用 <code>NSStringFromSelector</code> ，將 selector 轉換成 <code>NSString</code>
，反之，也可以使用 <code>NSSelectorFromString</code> 將 <code>NSString</code> 轉成 selector。</p>
<h3 id="-private-api">…呼叫 Private API</h3>
<p>Objective-C 裡頭其實沒有真正所謂的 private method，一個物件實作了那些
method，即使沒有 import 對應的
header，我們都呼叫得到。系統裡頭許多原本就內建的 class，有一些 header
並沒有宣告的 method，但是從一些相關網站或是其他管道，我們就是知道有這些
method，先不管究竟是什麼原因，我們有的時候就是想要呼叫看看，這時候我們往往會用
<code>performSelector:</code> 呼叫。原因也很簡單：因為我們沒有 header。</p>
<p>但我們並不建議做這樣的事情：今天一個 method 沒有被放在 header
裡頭，就代表在作業系統改版的時候，系統可能把整個底層的實作換掉，這個
method 可能就此消失，而造成系統升級之後，因為呼叫不存在的 method
而造成應用程式 crash。而如果你打算寫一套 iOS 應用程式，在 AppSrtore
上架販售，蘋果的審查過程中就會拒絕使用 private API 的軟體。</p>
<h2 id="-performselector-">呼叫 <code>performSelector:</code> 需要注意的地方</h2>
<p>我們在呼叫 <code>performSelector:</code> 的時候要注意幾點：</p>
<h3 id="-super--performselector">對 super 呼叫 performSelector:</h3>
<p>前面雖然提到，對一個物件直接呼叫某個 method，或是透過 <code>performSelector:</code>
呼叫，意義是一樣的，但如果是對 super 呼叫，卻有不一樣的結果。如果是：</p>
<pre><code class="lang-objc">[<span class="hljs-keyword">super</span> doSomthing];
</code></pre>
<p>代表的是呼叫 super 的 doSomthing 實作。但如果是：</p>
<pre><code class="lang-objc">[<span class="hljs-keyword">super</span> performSelector:<span class="hljs-keyword">@selector</span>(doSomething)];
</code></pre>
<p>呼叫的是 super 的 <code>performSelector:</code> ，最後結果仍然等同於
<code>[self doSomething]</code> 。</p>
<h3 id="refactor-">Refactor 工具</h3>
<p>隨著專案的發展，我們可能後來覺得當初某個 method
的命名並不恰當，所以想要換個名字，這時候與其使用搜尋/替代功能，不如直接使用
Xcode 提供的 Refactoring 工具：在想要改名字的 method
上面點選滑鼠右鍵，就會出現選單，然後從「Refactor」中選擇「Rename」。</p>
<p><img src="selector/rename.png" alt="Refactor 選單中的 Rename 功能"></p>
<p>執行之後，Xcode 除了把這個 method
的名字換掉，也會同時更新所有專案中呼叫這個 method
的程式，但，如果我們當初是用 <code>performSelector:</code> 呼叫要執行的
method，Xcode 並不會把裡頭的 selector
也換掉，只會出現簡短的警告訊息而已，如果我們忽略了這些警告，之後執行的時候，就會出現找不到
selector 的錯誤。我們需要格外小心。</p>
<blockquote id="fn_1">
<sup>1</sup>. 不過，如果你直接在程式裡頭這麼呼叫，Xcode 會在編譯的時候發出警告，告訴你在不久的將來會禁止這樣直接呼叫物件的成員變數，如果想要取用成員變數，必須另外寫 getter/setter。而如果這個成員變數被宣告成是 private 的，Xcode 會直接出現編譯錯誤，禁止你這樣呼叫。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 這種強調物件有哪些 method，會比物件繼承自哪個 Class 來得重要的觀念，有一個專有名詞，叫做 Duck Typing，中文翻譯做「鴨子型別」。觀念是：我眼前這個東西到底是不是鴨子？它是不是鳥類或是哪個種類根本就不重要，反正它走路游泳像鴨子ˇ，叫起來像鴨子，那我就當它是鴨子。可以參見 Wikipedia 上的說明： <a href="http://en.wikipedia.org/wiki/Duck_typing" target="_blank">http://en.wikipedia.org/wiki/Duck_typing</a> 。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 參見 <a href="http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_4_4.html" target="_blank">http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_4_4.html</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../index.html" class="navigation navigation-prev " aria-label="Previous page: Introduction"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../category/README.html" class="navigation navigation-next " aria-label="Next page: Category"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
