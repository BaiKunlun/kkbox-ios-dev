<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>Delegate | KKBOX iOS 開發教材</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.3">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    
    <link rel="prev" href="../memory_management_part_1/README.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book"  data-level="4" data-basepath=".." data-revision="1438326341831">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="selector/README.html">
            
                
                    <a href="../selector/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         Selector
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="category/README.html">
            
                
                    <a href="../category/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Category
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="memory_management_part_1/README.html">
            
                
                    <a href="../memory_management_part_1/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         Memory Management Part 1
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="4" data-path="delegate/README.html">
            
                
                    <a href="../delegate/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         Delegate
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" >KKBOX iOS 開發教材</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_85">
                    
                        <h1 id="delegate--protocol">Delegate 與 Protocol</h1>
<p>相信在閱讀這一章之前，你應該已經寫過一些簡單的 iOS
程式，知道如果我們想要一個像是系統設定（Setting.app）那樣的表格介面，我們會建立
<code>UITableViewController</code> 的 subclass，這個 controller 的 view 是
<code>UITableView</code>。</p>
<p>當我們想要設定表格中的內容，像是這個表格中有多少個 section、每個 section
裡頭有多少 row、每個 row 裡頭又是哪些內容…我們不是直接呼叫 <code>UITableView</code>
的 method，像是呼叫 <code>[myTableView setSectionCount:3]</code> 或是
<code>[myTableView setRowCount:3 atSection:4]</code>，而是去實作
<code>UITableViewController</code> 裡頭幾個像是 template method 的東西，像
<code>numberOfSectionsInTableView:</code>、<code>tableView:numberOfRowsInSection:</code>
等等。</p>
<p>為什麼不是直接去改變 view，而是 controller 要準備一些不知道會被誰呼叫的
method？理由是：<code>UITableViewController</code> 是 <code>UITableView</code> 的 data source
與 delegate。那，什麼是 delegate？</p>
<p>用我的話來說，delegate 就是 <em>將眾多的 callback，集中在一個物件上</em> 。</p>
<h2 id="-objective-c--delegate">從其他平台來看 Objective-C 的 Delegate</h2>
<p>Delegate 算是入門 Objective-C
的另外一個障礙，但了解之後就會知道其實很簡單，一開始可能覺得並不好懂的主要原因是，delegate
的這套作法，跟其他平台在做同樣的事情的時候，作法比較不一樣。</p>
<p>如果你曾經在其他的平台上開發過應用程式，像是微軟的 .Net
平台的話，可以發現，在 C# 語言中在講一個 class 有哪些成員的時候，會包括
properties、methods 以及 events；但是我們在講 Objective-C 的 class
時，並不會提到 events，C# 中使用 events 在做的事情，在 Objective-C
中，我們往往使用 target/action 與 delegate 實作。 <sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>雖然在 Mac OS X 與 iOS 上分別有 <code>NSEvent</code> 與 <code>UIEvent</code>，但是這邊的
events 與 .Net 裡頭講的 events 又是兩件事情：<code>NSEvent</code>
是用來描述鍵盤按了哪個按鍵，滑鼠移到了什麼位置，而 <code>UIEvent</code>
則用來描述觸控事件以及耳機上的播放控制按鈕等等，單純用來描述從硬體輸入了什麼事件，透過作業系統傳到我們的應用程式中。而
C# 裡頭所稱的 events，則是用來處理 callback。</p>
<p>所謂 callback 是指，當我們呼叫了一個 function 或 method
之後，可能會花上許多時間，或是計算的是大量資料，或是需要透過網路連線，所以我們並不馬上要求得到回傳的結果，而是等到一段時間之後，計算結果才會透過另外一個
function/method 傳回來。</p>
<p>現在絕大多數的應用程式開發環境都採用 MVC
架構，我們將物件分成三類：model、view、controller，雖然在不同的平台上往往實作出來的結果不太一樣，像是在微軟的平台上，往往把
window （或是 form）當做是 controller 使用，由 window
物件負責管理放在這個 window 上面所有的 control 元件，但是 Mac OS X 上面
window 並不拿來當做 controller，而是被當成 view，controller 在 window
之外，而且一個 controller 也可以控制多個 window…但都大抵如此。</p>
<p>在 MVC 的架構中，我們通常會先建好 controller class，然後加入 model 與
view，變成 controller 的成員變數；因為 model 與 view 是 controller
的成員變數，所以 controller 可以直接呼叫 model 與 view，那麼，當 model
與 view 發生了變化，要回來通知 controller，我們也可以稱之為
callback，例如，controller
建立了一個按鈕，但是直到按鈕被點選之後，controller 才負責做事。</p>
<p>在 C# 中，我們要處理一個 event，就要提供一個 event
handler，我們現在要處理的是 Click：</p>
<pre><code class="lang-csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeComponent</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">this</span>.button1 = <span class="hljs-keyword">new</span> System.Windows.Forms.Button();
    <span class="hljs-keyword">this</span>.button1.Click += Button1_Click;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">(<span class="hljs-keyword">object</span> sender, System.EventArgs e)</span>
</span>{
}
</code></pre>
<p>如果只是單純的點選事件的話，我們會用 target/action 實作。但，對照 .Net
framework 裡頭，events 不只是 click 而已，還可能會有 double
click、triple click、quadruple click…，如果是 C# 裡頭，會這麼寫：</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">this</span>.button1.Click += Button1_Click;
<span class="hljs-keyword">this</span>.button1.DoubleClick += Button1_DoubleClick;
<span class="hljs-keyword">this</span>.button1.TripleClick += Button1_TripleClick;
<span class="hljs-keyword">this</span>.button1.QuadrupleClick += Button1_QuadrupleClick;
</code></pre>
<p>變成 Objective-C 的話就可能變成：</p>
<pre><code class="lang-objc">[button1 setTarget:<span class="hljs-keyword">self</span>];
[button1 setAction:<span class="hljs-keyword">@selector</span>(click:)];
[button1 setDoubleTarget:<span class="hljs-keyword">self</span>];
[button1 setDoubleAction:<span class="hljs-keyword">@selector</span>(doubleClick:)];
[button1 setTripleTarget:<span class="hljs-keyword">self</span>];
[button1 setTripleAction:<span class="hljs-keyword">@selector</span>(tripleClick:)];
[button1 setQuadrupleTarget:<span class="hljs-keyword">self</span>];
[button1 setQuadrupleAction:<span class="hljs-keyword">@selector</span>(QuadrupleClick:)];
</code></pre>
<p>這樣寫起來實在很讓人煩躁（雖然 <code>NSTableView</code> 也的確有 <code>setDoubleAction:</code>
…），所以，當這樣的東西一多，在 Objective-C
語言裡頭，會直接準備好一個物件，這個物件準備好了所有可以呼叫的
method，這個物件就叫做 delegate，而這些可以呼叫的 method 的集合，叫做
protocol。準備好這個物件之後，我們就不用呼叫這麼多
<code>setDoubleAction:</code>、<code>setTripleAction:</code>，只要呼叫 <code>setDelegate:</code>。</p>
<h2 id="-protocol--delegate-">設計 Protocol 與實作 Delegate 的方式</h2>
<p>我們來用 delegate 的想法來實作前面提到的狀況。</p>
<h3 id="-protocol--delegate-">宣告 Protocol 與 Delegate 的方式</h3>
<p>我們先來建立一個 <code>NSButton</code> 的 subclass，叫做 <code>MyButton</code>， <code>MyButton</code> 的
delegate 必須實作 <code>MyButtonDelegate</code> 這個 protocol。.h 檔案中宣告如下：</p>
<pre><code class="lang-objc"><span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Cocoa/Cocoa.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">MyButton</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">MyButtonDelegate</span></span>
- (<span class="hljs-keyword">void</span>)myButtonDidBecomeClicked:(MyButton *)button;
- (<span class="hljs-keyword">void</span>)myButtonDidBecomeDoubleClicked:(MyButton *)button;
- (<span class="hljs-keyword">void</span>)myButtonDidBecomeTripleClicked:(MyButton *)button;
- (<span class="hljs-keyword">void</span>)myButtonDidBecomeQuadrupleClicked:(MyButton *)button;
<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyButton</span> : <span class="hljs-title">NSButton</span></span>
{
    <span class="hljs-keyword">id</span> &lt;MyButtonDelegate&gt; delegate;
}
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> &lt;MyButtonDelegate&gt; delegate;
<span class="hljs-keyword">@end</span>
</code></pre>
<p>逐行解釋這個 header 裡頭的內容：</p>
<ol>
<li><code>#import &lt;Cocoa/Cocoa.h&gt;</code> ：因為 NSButton 是在 AppKit
裡頭，所以我們必須呼叫對應的 header。</li>
<li><code>@class MyButton;</code> ：因為在我們接下來的 protocol 宣告中，會用到
<code>MyButton</code> 這個 class，但是 <code>MyButton</code> 其實是宣告在
<code>MyButtonDelegate</code> 的下面，所以我們需要先預先宣告 <code>MyButton</code> 這個
class 的存在。</li>
<li>從 <code>@protocol MyButtonDelegate</code> 開始，就是在宣告 <code>MyButtonDelegate</code>
這個 protocol 裡頭的四個 method。</li>
<li>接下來宣告 <code>MyButton</code> 這個 class，裡頭有一個叫做 delegate 的變數。</li>
</ol>
<h3 id="-delegate-methods">實作 Delegate Methods</h3>
<p>假如我們有一個叫做 <code>MyController</code> 的 controller 物件，要成為 <code>MyButton</code>
的 delegate，我們會這麼做。首先是 .h 部分：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyController</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">MyButtonDelegate</span>&gt;</span>
{
    <span class="hljs-keyword">IBOutlet</span> MyButton *myButton;
}
<span class="hljs-keyword">@end</span>
</code></pre>
<p>我們要先宣告 <code>MyController</code> 有實作 <code>MyButtonDelegate</code> 這個
protocol，如此一來，假如 <code>MyController</code> 漏了實作哪些定義在
<code>MyButtonDelegate</code> 裡頭的
method，在編譯的時候就會跳出警告，要求我們修正，如果我們還是不實作的話，執行時，就會發生找不到
selector 對應的實作的錯誤而 crash。</p>
<p>如果 <code>MyController</code> 又是其他物件的 delegate
的話，我們可以在這段用大於與小於間包起來的宣告，繼續加入其他的 protocol
的名稱，例如
<code>&lt;MyButtonDelegate, AnotherProtocol&gt;</code>。至於一個物件是否有實作某個
protocol，我們可以用 <code>conformsToProtocol:</code> 檢查。</p>
<p>在 <code>MyController</code> 的實作中，我們就只要將 <code>myButton</code> 的 delegate
設成自己，然後實作該實作的 method。我個人不太喜歡在 protocol
的宣告中出現大量註解，因為在實作 protocol 的時候，最方便的方式就是直接把
protocol 宣告的 method 複製貼上，接著逐一把肉放進 protocol
定義的骨幹裡；如果當中出現註解，複製貼上之後，還要把這些註解刪掉，其實還頂煩人。</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyController</span></span>

- (<span class="hljs-keyword">void</span>)awakeFromNib
{
    [myButton setDelegate:<span class="hljs-keyword">self</span>];
}

<span class="hljs-preprocessor">#pragma mark - MyButtonDelegate</span>

- (<span class="hljs-keyword">void</span>)myButtonDidBecomeClicked:(MyButton *)button
{
}
- (<span class="hljs-keyword">void</span>)myButtonDidBecomeDoubleClicked:(MyButton *)button
{
}
- (<span class="hljs-keyword">void</span>)myButtonDidBecomeTripleClicked:(MyButton *)button
{
}
- (<span class="hljs-keyword">void</span>)myButtonDidBecomeQuadrupleClicked:(MyButton *)button
{
}

<span class="hljs-keyword">@end</span>
</code></pre>
<p>我們在這邊透過 <code>setDelegate:</code> 指定 delegate，如果我們把 delegate
宣告成是一個 IBOutlet 的話，也可以直接在 Interface Builder 中連結。</p>
<h3 id="delegate-methods-">Delegate Methods 是怎麼被呼叫的？</h3>
<p><code>MyButton</code> 是怎樣呼叫 delegate 的呢？其實很簡單。</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyButton</span></span>

- (<span class="hljs-keyword">void</span>)mouseDown:(NSEvent *)theEvent
{
    <span class="hljs-keyword">switch</span> ([theEvent clickCount]) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            [delegate myButtonDidBecomeClicked:<span class="hljs-keyword">self</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            [delegate myButtonDidBecomeDoubleClicked:<span class="hljs-keyword">self</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            [delegate myButtonDidBecomeTripleClicked:<span class="hljs-keyword">self</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            [delegate myButtonDidBecomeQuadrupleClicked:<span class="hljs-keyword">self</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-keyword">@synthesize</span> delegate;
<span class="hljs-keyword">@end</span>
</code></pre>
<h2 id="">注意事項</h2>
<p>在上面的範例中，我們看到了設計 delegate 與 protocol 應該注意的地方：</p>
<h3 id="delegate--class">Delegate 物件不應該指定 Class</h3>
<p>我們將 delegate 物件宣告成 <code>id &lt;MyButtonDelegate&gt; delegate</code>
，意思就是不需要管這個物件屬於哪個 class，只要是個 Objective-C
物件即可，但是這個物件必須實作 <code>MyButtonDelegate</code> protocol。</p>
<p>我們其實可以將 delegate 物件是那個 class 寫死，例如把 <code>MyButton</code> 的
delegate 的 class 指定成
<code>MyController</code>，但這樣做非常不好，如此一來，就只有 <code>MyController</code>
可以使用 <code>MyButton</code>，其他 controller 都無法使用，就大大減少了重複使用
<code>MyButton</code> 的彈性。</p>
<p>Delegate 這種設計方式，也方便我們在同時開發 Mac OS X 與 iOS
跨平台專案時共用程式碼，我們在撰寫某個 model 物件的時候，只使用
Foundation 或是其他兩個平台都有的
framework，至於與平台相依的部份，就放進 delegate 中，然後在 Mac OS X 與
iOS 上各自實作 delegate 物件。</p>
<p>總之， <em>在實作 delegate 的時候，delegate 屬於哪個 class
並不重要，重要的是 delegate 物件有沒有實作我們想要呼叫的 method。</em></p>
<h3 id="delegate--assign-retain">Delegate 屬性應該要用 Assign，而非 Retain</h3>
<p>在使用 property 語法的時候，如果這個 property 是 Objective-C
物件，我們照理說應該要設定成 retain，但是遇到的是 delegate，我們應該設成
assign。</p>
<p>原因是：需要設計 delegate 物件的這個物件，往往是其 delegate
物件的成員變數。在我們的例子中，<code>MyButton</code> 的 instance 是 <code>myButton</code>，是
<code>MyController</code> 的成員變數，自己可能已經被 <code>MyController</code> retain
了一份（雖然 Mac OS X 上的 IBOutlet 只需要設成 assign，但是 iOS 上，
<code>UIViewController</code> 會 retain IBOutlet），如果 <code>MyButton</code> 又 retain
了一次 <code>MyController</code>，就會出現循環 retain 的問題—我已經被別人
retain，我又把別人 retain 一次。</p>
<p>如此，會造成我們會無法釋放 <code>MyController</code>：在該釋放 <code>MyController</code>
的時候，<code>MyController</code> 還是被自己的成員變數 retain，<code>MyController</code>
得要走到 <code>dealloc</code> 才會釋放 <code>myButton</code>，但是自己卻因為被 <code>myButton</code> 給
retain 起來，而始終走不到 <code>dealloc</code>。</p>
<h4 id="delegate-method-">Delegate Method 的命名方式</h4>
<p>Delegate method 的命名有個鮮明的特色，就是這個 method
至少會傳入一個參數，就是把到底是誰呼叫了這個 delegate method
傳遞進來。同時，這個 method 也往往以傳入的 class
名稱開頭，讓我們可以辨識這是屬於哪個 class 的 delegate method。以
<code>UITableViewDelegate</code> 為例，假如我們在 iOS
的表格中，選擇了某一列，就會呼叫</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView
        didSelectRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath
</code></pre>
<p>Method 的名稱就以「tableView」開頭，讓我們知道這是屬於 Table View 的
delegate method，然後第一個參數把這個 Table View 的 iinstance
傳入，接下來才傳入到底是哪一列被選起來的資訊。</p>
<p>至少把是誰呼叫了這個 delegate method 傳入的理由很簡單。以我們的
<code>MyController</code> 為例，這個 controller 可能有好幾個 <code>MyButton</code>，而這些
<code>MyButton</code> 全都把 delegate 指到同一個 controller 上，那麼，controller
就需要知道到底是被哪個 button 呼叫。判斷方式只要簡單比對指標就好了：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)myButtonDidBecomeQuadrupleClicked:(MyButton *)button
{
    <span class="hljs-keyword">if</span> (button == myButton1) {
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (button == myButton2) {
    }
}
</code></pre>
<h2 id="data-source--delegate-">Data Source 與 Delegate 的差別？</h2>
<p>我們現在可以來看看 <code>UITableView</code> 與 <code>UITableViewController</code>
是怎麼運作的。 <code>UITableViewController</code> 在 <code>loadView</code> 中建立了一個
<code>UITableView</code> 的 instance，指定成是自己的 view，同時將這個 view 的
delegate 與 data source 設定成自己。一個 class 可以根據需要，將 delegate
拆成好幾個，以 <code>UITableView</code> 來說，跟表格中有什麼資料有關的，就放在 data
source 中，其餘的 method 放在 delegate 中。</p>
<p>我們在 Mac OS X 會用到的最龐大的 UI 元件，莫過於 <code>WebView</code>，雖然在 iOS
上 <code>UIWebView</code> 被閹割到只剩下四個 delegate method，但是 Mac OS X
上足足有五大類 delegate
method，網頁頁框的載入進度、個別圖片檔案的載入進度、下載檔案的 UI
呈現、該不該開新視窗或是新分頁、沒有安裝 Java 或是 Flash 要怎麼呈現、用
JavaScript 跳出 alert 該怎麼呈現…都是一堆 delegate method。</p>
<p>假如先不管 <code>UITableView</code> 怎麼重複使用 <code>UITableViewCell</code>
的機制（這個機制還頂複雜），我們要更新 <code>UITableView</code> 的資料時，先指定
data source 物件後，要呼叫一次 <code>reloadData</code> 。 <code>reloadData</code>
可能是這樣寫的：</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)reloadData
{
    <span class="hljs-built_in">NSInteger</span> sections = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> ([dataSource respondsToSelector:
        <span class="hljs-keyword">@selector</span>(numberOfSectionsInTableView:)]) {
        sections = [dataSource numberOfSectionsInTableView:<span class="hljs-keyword">self</span>];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> section = <span class="hljs-number">0</span>; section &lt; sections; section++) {
        <span class="hljs-built_in">NSInteger</span> rows = [dataSource tableView:<span class="hljs-keyword">self</span>
                         numberOfRowsInSection:section];
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> row = <span class="hljs-number">0</span>; row &lt; rows; row++) {
            <span class="hljs-built_in">NSIndexPath</span> *indexPath = [<span class="hljs-built_in">NSIndexPath</span> indexPathForRow:row
                                                        inSection:section];
            <span class="hljs-built_in">UITableViewCell</span> *cell = [dataSource tableView:<span class="hljs-keyword">self</span>
                                    cellForRowAtIndexPath:indexPath];
            <span class="hljs-comment">// Do something with the cell...</span>
        }
    }
}
</code></pre>
<p>我們注意到幾件事情：首先，因為 <code>numberOfSectionsInTableView:</code> 被定義成是
optional 的 delegate method，delegate 不見得要實作，所以我們會用
<code>respondsToSelector:</code> 檢查是否有實作。我們可以在 protocol
的宣告中，指定某個 delegate method 是 required 或是
optional，如果不特別指定的話，預設都是 required。我們簡單看一下
<code>UITableViewDataSource</code> 就知道如何定義 required 與 optional 的 delegate
method。</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">UITableViewDataSource</span>&lt;<span class="hljs-title">NSObject</span>&gt;</span>
<span class="hljs-keyword">@required</span>
- (<span class="hljs-built_in">NSInteger</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView
  numberOfRowsInSection:(<span class="hljs-built_in">NSInteger</span>)section;
- (<span class="hljs-built_in">UITableViewCell</span> *)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView
  cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath;
<span class="hljs-keyword">@optional</span>
- (<span class="hljs-built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="hljs-built_in">UITableView</span> *)tableView;
<span class="hljs-comment">// ....</span>
<span class="hljs-keyword">@end</span>
</code></pre>
<p>另外，就是定義在 data source 的 method，是在 <code>reloadData</code>
中被呼叫，因此我們可以知道 <code>UITableView</code> 的 data source 與 delegate
的最大差別：我們絕對不可以在 data source 定義的 method 中呼叫
<code>reloadData</code>，不然就會進入無窮迴圈！</p>
<h2 id="formal-protocol--informal-protocol">Formal Protocol 與 Informal Protocol</h2>
<p><code>@protocol</code> 這個關鍵字是在 Objective-C 2.0 之後出現的，在這之前要定義
protocol，則是寫成 NSObject 的 category，前者叫做 formal
protocol，後者則稱為 informal protoco。UIKit 問世時就採用 Objective-C
2.0 語法，至於 Mac OS X，蘋果在 2008 年開始大幅改寫 Foundation 與
AppKit，現在（2012 年）絕大多數可以看到的 protocol，都是 formal
protocol，但如果你在 maintain 一份稍微有點歷史的程式，或是在蘋果少數的
API 中，還是可以看到 informal protocol。</p>
<p>在 Core Animation 裡頭，就可以看到
<code>CALayerDelegate</code>、<code>CALayoutManager</code>、<code>CAAnimationDelegate</code>，都還是
informal protocol。其中 <code>CALayerDelegate</code>、<code>CALayoutManager</code>
兩者之間還夾著 <code>CAAction</code> 這個 formal protocol—在兩個 informal protocol
中間夾著一個 formal protocol，實在讓人很反感—為什麼不一起改掉呢？至於
<code>CAAnimationDelegate</code> 也很怪異：CAAnimation 的 delegate 不是用
assign，而是會 retain 起來。</p>
<h2 id="-delegate">無所不在的 Delegate</h2>
<p>由於在 Objective-C 語言中，delegate 相當於 event handler
的用途，所以，當你在其他平台中看到 event handler 用得多頻繁，就等於
delegate 用得多頻繁。舉例來說：</p>
<ul>
<li>在使用 <code>NSURLConnection</code> 抓取網路上的資料的時候，無論收到了 HTTP
response code、是否連線失敗、是否連線結束…都是透過 delegate 回傳。</li>
<li>在使用 Core Location 的時候，如果 <code>CLLocationManager</code>
找到了我們的所在位置，或是發現我們正在移動，也都會透過 delegate
通知。</li>
<li>當我們要使用手機拍照、傳送簡訊或是電子郵件等等，當照片拍完，會用
delegate 回傳 image 物件，簡訊或是電子郵件傳送成功，也會用 delegate
告訴我們執行完畢。</li>
</ul>
<p>甚至，當我們在寫一個 iOS 程式的第一步，其實都是在實作一個 delegate
method。我們在 Xcode 裡頭開了一個新專案之後，下一步往往是實作
<code>application:didFinishLaunchingWithOptions:</code> 這個
method，但是要了解整個程式的進入點，我們要從 <code>main.m</code>
來看。裡頭通常只有簡短的幾行：</p>
<pre><code class="lang-objc"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])
{
    <span class="hljs-keyword">@autoreleasepool</span> {
        <span class="hljs-keyword">return</span> UIApplicationMain(argc, argv, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>));
    }
}
</code></pre>
<p>一個 iOS 程式是從 <code>main</code> 這個 function 開始，接著透過呼叫
<code>UIApplicationMain</code> 建立 <code>UIApplication</code> 這個 Singleton 物件。
<code>UIApplication</code> 用來代表一個應用程式的基本狀態，包括 icon
上面該顯示多少則 push notification
的數量、支援水平還是垂直畫面、是否顯示狀態列等，當 <code>UIApplication</code>
物件被建立起來後，就要通知它的
delegate—程式已經開啟了，請進行下一步，這個 delegate method 就是
<code>application:didFinishLaunchingWithOptions:</code>，我們在這邊建立基本的 view
controller 與 window，顯示出來。</p>
<p>也就是說，當我們在開始寫第一行 iOS 程式的時候，我們就起碼需要了解什麼是
Singleton 和 delegate，但是在了解之後，想要知道 Mac OS X 與 iOS
中眾多的元件該如何使用，以及怎樣用比較好的方式設計自己的元件，就不是問題了。</p>
<h2 id="-delegate">其他平台上所謂的 Delegate</h2>
<p>在其他平台中，也用到了 delegate 這個詞，但是意義不太一樣。</p>
<h3 id="design-pattern--delegate">Design Pattern 中所講的 Delegate</h3>
<p>就我的理解，Design Pattern 中所講的 Delegate Pattern，比較像是做一個
Wrapper，有一個 class 在實作 method 時，其實是直接把這個 method
的實作傳遞到自己的成員變數物件的實作上。以 Objective-C
語言實作會像這樣：</p>
<p>首先產生一個內部的物件，叫做 <code>MyInnerClass</code>：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyInnerClass</span> : <span class="hljs-title">NSObject</span></span>
- (<span class="hljs-keyword">void</span>)doSomething;
<span class="hljs-keyword">@end</span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyInnerClass</span></span>
- (<span class="hljs-keyword">void</span>)doSomething
{
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Do something"</span>);
}
<span class="hljs-keyword">@end</span>
</code></pre>
<p>然後， <code>MyClass</code> 會把該做的事情，都交給 <code>MyInnerClass</code>：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span>
{
    MyInnerClass *innerObject;
}
- (<span class="hljs-keyword">void</span>)doSomething;
<span class="hljs-keyword">@end</span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span>
- (<span class="hljs-keyword">void</span>)dealloc
{
    [innerObject release];
    [<span class="hljs-keyword">super</span> dealloc];
}
- (<span class="hljs-keyword">id</span>)init
{
    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) {
        innerObject = [[MyInnerClass alloc] init];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
- (<span class="hljs-keyword">void</span>)doSomething
{
    [innerObject doSomething];
}
<span class="hljs-keyword">@end</span>
</code></pre>
<p>在 Cocoa Framework 中，會比較像是 <code>NSButton</code> 與 <code>NSButtonCell</code>
的關係。你或許會問，為什麼 Objective-C 裡頭的 delegate 與 Design Pattern
裡頭講的 Delegate Pattern 意義不一樣？為什麼 Objective-C
不按照這套用法？但其實是， Objective-C 使用 delegate 這個觀念，早於
Design Pattern 成書。</p>
<h3 id="c--delegate">C# 中所謂的 Delegate</h3>
<p>C# 語言中也有 delegate 這個關鍵字，不過用途卻是處理 anonymous
function，以我們上面的例子，我們打算用 C# 增加按鈕被點選的 event
handler，原本是這麼寫：</p>
<p>``` {.sourceCode .c#}
private void InitializeComponent()
{
    this.button1 = new System.Windows.Forms.Button();
    this.button1.Click += Button1_Click;
}</p>
<p>private void Button1_Click(object sender, System.EventArgs e)
{
}</p>
<pre><code>
在 C\# 2.0 可以寫成這樣： [^2]

``` {.sourceCode .c#}
private void InitializeComponent()
{
    this.button1 = new System.Windows.Forms.Button();
    this.button1.Click += delegate(object sender, System.EventArgs e) {
    // Do something here.
    };
}
</code></pre><p>關於在 Objective-C 語言中怎麼使用 anonymous
function，我們會在接下來的章節，講 block 的時候討論。</p>
<h2 id="">我曾經犯過的低級錯誤</h2>
<p>最後來提一個我之前花了半個月才找出問題在哪的 bug。問題出在 protocol
不該這麼設計。我之前寫了一個 class，這個 class 有兩個 method： <code>begin</code>
與 <code>stop</code>，按下 <code>begin</code> 的時候要開始做一件事情，之後想要停止，就呼叫
<code>stop</code>，要開始或要結束的時候，都會通知 delegate。程式大概是這樣：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">MyClass</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">MyClassDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span>
- (<span class="hljs-keyword">void</span>)myClassWillBegin:(MyClass *)myClasss;
- (<span class="hljs-keyword">void</span>)myClassDidBegin:(MyClass *)myClasss;
- (<span class="hljs-keyword">void</span>)myClassWillStop:(MyClass *)myClasss;
- (<span class="hljs-keyword">void</span>)myClassDidStop:(MyClass *)myClasss;
<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span>
{
    <span class="hljs-keyword">id</span> &lt;MyClassDelegate&gt; delegate;
}
- (<span class="hljs-keyword">void</span>)begin;
- (<span class="hljs-keyword">void</span>)stop;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> &lt;MyClassDelegate&gt; delegate;
<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span>

- (<span class="hljs-keyword">void</span>)begin
{
    [delegate myClassWillBegin:<span class="hljs-keyword">self</span>];
    <span class="hljs-comment">// Do something</span>
    [delegate myClassDidBegin:<span class="hljs-keyword">self</span>];
}
- (<span class="hljs-keyword">void</span>)stop
{
    [delegate myClassWillStop:<span class="hljs-keyword">self</span>];
    <span class="hljs-comment">// Do something</span>
    [delegate myClassDidStop:<span class="hljs-keyword">self</span>];
}
<span class="hljs-keyword">@synthesize</span> delegate;
<span class="hljs-keyword">@end</span>
</code></pre>
<p>這個 protocol 有什麼問題呢？就像前面提到，在 <code>UITableView</code> 的 data
source 的 method 裡頭不該呼叫 <code>reloadData</code> 一樣，這邊的幾個 delegate
method 的實作裡頭，也都不該隨意的呼叫 <code>begin</code> 與 <code>stop</code> ，而我在
<code>myClassWillBegin:</code>
裡頭想要做一些檢查，如果在某些條件下，這件事情不該跑起來，而應該停止，所以我在
<code>myClassWillBegin:</code> 裡頭呼叫了
<code>stop</code>。但這麼做，並不會讓這件事情結束，因為 <code>begin</code> 這個 method 在對
delegate 呼叫完 <code>myClassWillBegin:</code>
之後，程式還是會繼續往下走，所以還是把 begin 整個做完了。</p>
<p>這個 protocol 應該這麼設計：</p>
<pre><code class="lang-objc"><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">MyClass</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">MyClassDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span>
- (<span class="hljs-built_in">BOOL</span>)myClassShouldBegin:(MyClass *)myClasss;
- (<span class="hljs-keyword">void</span>)myClassDidBegin:(MyClass *)myClasss;
- (<span class="hljs-built_in">BOOL</span>)myClassShouldStop:(MyClass *)myClasss;
- (<span class="hljs-keyword">void</span>)myClassDidStop:(MyClass *)myClasss;
<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span>
{
    <span class="hljs-keyword">id</span> &lt;MyClassDelegate&gt; delegate;
}
- (<span class="hljs-keyword">void</span>)begin;
- (<span class="hljs-keyword">void</span>)stop;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> &lt;MyClassDelegate&gt; delegate;
<span class="hljs-keyword">@end</span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span>

- (<span class="hljs-keyword">void</span>)begin
{
    <span class="hljs-keyword">if</span> (![delegate myClassShouldBegin:<span class="hljs-keyword">self</span>]) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// Do something</span>
    [delegate myClassDidBegin:<span class="hljs-keyword">self</span>];
}
- (<span class="hljs-keyword">void</span>)stop
{
    <span class="hljs-keyword">if</span> (![delegate myClassShouldStop:<span class="hljs-keyword">self</span>]) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// Do something</span>
    [delegate myClassDidStop:<span class="hljs-keyword">self</span>];
}
<span class="hljs-keyword">@synthesize</span> delegate;
<span class="hljs-keyword">@end</span>
</code></pre>
<blockquote id="fn_1">
<sup>1</sup>. 我在寫這章的時候，一直在想拿 C# 到底是不是好主意，畢竟想要學 Objective-C 語言者，不見得都有 C# 的基礎。之所以以 C# 舉例，原因是這份資料其實是來自於當初我個人在公司內部的教材，而公司當時進來的新人之前是寫 C# 的。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 參見 <a href="http://msdn.microsoft.com/en-us/library/bb882516.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/bb882516.aspx</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../memory_management_part_1/README.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Memory Management Part 1"><i class="fa fa-angle-left"></i></a>
        
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
